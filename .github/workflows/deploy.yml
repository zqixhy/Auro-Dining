name: Aura Dining CI/CD

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests'
        required: false
        default: 'true'
        type: boolean
      force_rebuild:
        description: 'Force rebuild Docker image (no cache)'
        required: false
        default: 'false'
        type: boolean
      deployment_note:
        description: 'Deployment note (optional)'
        required: false
        default: 'Manual deployment'
        type: string

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      EC2_HOST: ${{ secrets.EC2_HOST }}
      EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
      RDS_ENDPOINT: ${{ secrets.RDS_ENDPOINT }}
      DB_USERNAME: ${{ secrets.DB_USERNAME }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          java-version: '11'
          distribution: 'corretto'
          cache: maven

      - name: Build with Maven
        run: |
          SKIP_TESTS="${{ inputs.skip_tests }}"
          if [ -z "$SKIP_TESTS" ] || [ "$SKIP_TESTS" == "true" ]; then
            mvn clean package -DskipTests
          else
            mvn clean package
          fi

      - name: Prepare deployment package
        run: |
          mkdir -p deploy-package
          cp target/auro-dining-0.0.1-SNAPSHOT.jar deploy-package/
          cp src/main/resources/application-aws.yml deploy-package/
          cp Dockerfile deploy-package/
          cp deploy/docker-compose.yml deploy-package/
          cp deploy/install-docker.sh deploy-package/
          cp deploy/rollback-docker.sh deploy-package/
          # Convert line endings to prevent Windows CRLF from breaking Linux scripts
          sed -i 's/\r$//' deploy-package/install-docker.sh

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts

      - name: Copy files to EC2
        run: |
          ssh -i ~/.ssh/deploy_key ${EC2_USERNAME:-ec2-user}@$EC2_HOST "mkdir -p ~/auro-dining/incoming"
          scp -i ~/.ssh/deploy_key \
            deploy-package/* \
            ${EC2_USERNAME:-ec2-user}@$EC2_HOST:~/auro-dining/incoming/

      - name: Deploy on EC2 (Docker)
        env:
          RDS_ENDPOINT: ${{ secrets.RDS_ENDPOINT }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          FORCE_REBUILD: ${{ inputs.force_rebuild }}
        run: |
          ssh -i ~/.ssh/deploy_key ${EC2_USERNAME:-ec2-user}@$EC2_HOST << 'DEPLOY_SCRIPT'
            set -e
            set -x
          
            # Manually add paths that sudo might lose
            export PATH=$PATH:/usr/local/bin
          
            cd ~/auro-dining || { mkdir -p ~/auro-dining && cd ~/auro-dining; }
          
            if [ ! -f .installed ]; then
              chmod +x incoming/install-docker.sh
              ./incoming/install-docker.sh
              touch .installed
            fi
          
            # Move new files
            mv -f incoming/auro-dining-0.0.1-SNAPSHOT.jar .
            mv -f incoming/application-aws.yml .
            mv -f incoming/Dockerfile .
            mv -f incoming/docker-compose.yml .
            [ -f incoming/install-docker.sh ] && mv -f incoming/install-docker.sh . || true
            rm -rf incoming
          
            # Enhanced Docker Compose path detection
            if [ -f /usr/local/bin/docker-compose ]; then
              DOCKER_COMPOSE_CMD="/usr/local/bin/docker-compose"
            elif sudo docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              DOCKER_COMPOSE_CMD="docker-compose"
            fi
          
            echo "Using Docker Compose command: $DOCKER_COMPOSE_CMD"
          
            export RDS_ENDPOINT="${{ secrets.RDS_ENDPOINT }}"
            export DB_USERNAME="${{ secrets.DB_USERNAME }}"
            export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          
            BUILD_ARGS=""
            [ "${{ inputs.force_rebuild }}" == "true" ] && BUILD_ARGS="--no-cache"
          
            # Ensure Buildx is available and version >= 0.17.0
            echo "Checking Docker Buildx..."
            BUILDX_VERSION="0.0.0"
            if sudo docker buildx version >/dev/null 2>&1; then
              BUILDX_VERSION=$(sudo docker buildx version 2>&1 | grep -oP 'github.com/docker/buildx \K[0-9.]+' || echo "0.0.0")
              echo "Current Buildx version: $BUILDX_VERSION"
            fi
            
            # Check if version is less than 0.17.0
            NEED_UPGRADE=false
            if [ "$BUILDX_VERSION" = "0.0.0" ]; then
              echo "Buildx not found, installing..."
              NEED_UPGRADE=true
            else
              # Compare versions: check if version < 0.17.0
              # Extract major and minor version numbers
              MAJOR=$(echo $BUILDX_VERSION | cut -d. -f1)
              MINOR=$(echo $BUILDX_VERSION | cut -d. -f2)
              
              # Version comparison: need >= 0.17.0
              if [ "$MAJOR" -eq 0 ] && [ "$MINOR" -lt 17 ]; then
                echo "Buildx version $BUILDX_VERSION is too old (need >= 0.17.0), upgrading..."
                NEED_UPGRADE=true
              elif [ "$MAJOR" -gt 0 ]; then
                echo "Buildx version $BUILDX_VERSION is acceptable"
              else
                echo "Buildx version $BUILDX_VERSION is acceptable"
              fi
            fi
            
            if [ "$NEED_UPGRADE" = "true" ]; then
              echo "Installing/upgrading Buildx..."
              DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
              mkdir -p $DOCKER_CONFIG/cli-plugins
              
              # Download latest Buildx
              BUILDX_URL=$(curl -s https://api.github.com/repos/docker/buildx/releases/latest | grep "browser_download_url.*linux-x86_64" | cut -d '"' -f 4)
              if [ -z "$BUILDX_URL" ]; then
                BUILDX_URL="https://github.com/docker/buildx/releases/latest/download/buildx-v0.17.0.linux-amd64"
              fi
              
              curl -L "$BUILDX_URL" -o $DOCKER_CONFIG/cli-plugins/docker-buildx
              chmod +x $DOCKER_CONFIG/cli-plugins/docker-buildx
              
              # Install to system location
              sudo mkdir -p /usr/local/lib/docker/cli-plugins
              sudo rm -f /usr/local/lib/docker/cli-plugins/docker-buildx
              sudo cp $DOCKER_CONFIG/cli-plugins/docker-buildx /usr/local/lib/docker/cli-plugins/docker-buildx
              sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-buildx
              
              echo "Buildx upgraded, verifying..."
              sudo docker buildx version
            fi
            
            # Create and use default builder if needed
            sudo docker buildx ls >/dev/null 2>&1 || sudo docker buildx create --name default --use 2>/dev/null || true
            sudo docker buildx inspect --bootstrap >/dev/null 2>&1 || true
            
            echo "Final Buildx version:"
            sudo docker buildx version || echo "Buildx check completed"
            
            # Use -E to preserve environment variables
            sudo -E $DOCKER_COMPOSE_CMD build $BUILD_ARGS
            sudo -E $DOCKER_COMPOSE_CMD up -d
            sudo $DOCKER_COMPOSE_CMD ps
          DEPLOY_SCRIPT

      - name: Verify deployment
        run: |
          sleep 15
          curl -sf "http://$EC2_HOST/" || echo "Warning: Check Security Group Port 80/8080"