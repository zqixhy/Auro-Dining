name: Aura Dining CI/CD

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests'
        required: false
        default: 'true'
        type: boolean
      force_rebuild:
        description: 'Force rebuild Docker image (no cache)'
        required: false
        default: 'false'
        type: boolean
      deployment_note:
        description: 'Deployment note (optional)'
        required: false
        default: 'Manual deployment'
        type: string

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      EC2_HOST: ${{ secrets.EC2_HOST }}
      EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
      RDS_ENDPOINT: ${{ secrets.RDS_ENDPOINT }}
      DB_USERNAME: ${{ secrets.DB_USERNAME }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          java-version: '11'
          distribution: 'corretto'
          cache: maven

      - name: Build with Maven
        run: |
          SKIP_TESTS="${{ inputs.skip_tests }}"
          if [ -z "$SKIP_TESTS" ] || [ "$SKIP_TESTS" == "true" ]; then
            mvn clean package -DskipTests
          else
            mvn clean package
          fi

      - name: Prepare deployment package
        run: |
          mkdir -p deploy-package
          cp target/auro-dining-0.0.1-SNAPSHOT.jar deploy-package/
          cp src/main/resources/application-aws.yml deploy-package/
          cp Dockerfile deploy-package/
          cp deploy/docker-compose.yml deploy-package/
          cp deploy/install-docker.sh deploy-package/
          cp deploy/rollback-docker.sh deploy-package/
          # Convert line endings to prevent Windows CRLF from breaking Linux scripts
          sed -i 's/\r$//' deploy-package/install-docker.sh

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts

      - name: Copy files to EC2
        run: |
          ssh -i ~/.ssh/deploy_key ${EC2_USERNAME:-ec2-user}@$EC2_HOST "mkdir -p ~/auro-dining/incoming"
          scp -i ~/.ssh/deploy_key \
            deploy-package/* \
            ${EC2_USERNAME:-ec2-user}@$EC2_HOST:~/auro-dining/incoming/

      - name: Deploy on EC2 (Docker)
        env:
          RDS_ENDPOINT: ${{ secrets.RDS_ENDPOINT }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          FORCE_REBUILD: ${{ inputs.force_rebuild }}
        run: |
          ssh -i ~/.ssh/deploy_key ${EC2_USERNAME:-ec2-user}@$EC2_HOST << 'DEPLOY_SCRIPT'
            set -e
            set -x
          
            # Manually add paths that sudo might lose
            export PATH=$PATH:/usr/local/bin
          
            cd ~/auro-dining || { mkdir -p ~/auro-dining && cd ~/auro-dining; }
          
            if [ ! -f .installed ]; then
              chmod +x incoming/install-docker.sh
              ./incoming/install-docker.sh
              touch .installed
            fi
          
            # Move new files
            mv -f incoming/auro-dining-0.0.1-SNAPSHOT.jar .
            mv -f incoming/application-aws.yml .
            mv -f incoming/Dockerfile .
            mv -f incoming/docker-compose.yml .
            [ -f incoming/install-docker.sh ] && mv -f incoming/install-docker.sh . || true
            rm -rf incoming
          
            # Enhanced Docker Compose path detection
            if [ -f /usr/local/bin/docker-compose ]; then
              DOCKER_COMPOSE_CMD="/usr/local/bin/docker-compose"
            elif sudo docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              DOCKER_COMPOSE_CMD="docker-compose"
            fi
          
            echo "Using Docker Compose command: $DOCKER_COMPOSE_CMD"
          
            export RDS_ENDPOINT="${{ secrets.RDS_ENDPOINT }}"
            export DB_USERNAME="${{ secrets.DB_USERNAME }}"
            export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          
            BUILD_ARGS=""
            [ "${{ inputs.force_rebuild }}" == "true" ] && BUILD_ARGS="--no-cache"
          
            # Ensure Buildx is available and configured
            echo "Checking Docker Buildx..."
            if ! sudo docker buildx version >/dev/null 2>&1; then
              echo "Buildx not found, checking installation..."
              if [ -f /usr/local/lib/docker/cli-plugins/docker-buildx ]; then
                echo "Buildx found in system location"
              elif [ -f $HOME/.docker/cli-plugins/docker-buildx ]; then
                echo "Linking Buildx to system location..."
                sudo mkdir -p /usr/local/lib/docker/cli-plugins
                sudo cp $HOME/.docker/cli-plugins/docker-buildx /usr/local/lib/docker/cli-plugins/docker-buildx
                sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-buildx
              else
                echo "WARNING: Buildx not found, but continuing..."
              fi
            fi
            
            # Create and use default builder if needed
            sudo docker buildx ls >/dev/null 2>&1 || sudo docker buildx create --name default --use 2>/dev/null || true
            sudo docker buildx inspect --bootstrap >/dev/null 2>&1 || true
            
            echo "Buildx version:"
            sudo docker buildx version || echo "Buildx check completed"
            
            # Use -E to preserve environment variables
            sudo -E $DOCKER_COMPOSE_CMD build $BUILD_ARGS
            sudo -E $DOCKER_COMPOSE_CMD up -d
            sudo $DOCKER_COMPOSE_CMD ps
          DEPLOY_SCRIPT

      - name: Verify deployment
        run: |
          sleep 15
          curl -sf "http://$EC2_HOST/" || echo "Warning: Check Security Group Port 80/8080"